/* ZCM type definition class file
 * This file was automatically generated by zcm-gen
 * DO NOT MODIFY BY HAND!!!!
 */

package javazcm.types;
 
import java.io.*;
import java.util.*;
import zcm.zcm.*;
 
public final class bitfield_t implements zcm.zcm.ZCMEncodable
{
    public byte field1;
    public byte field2[][];
    public short field3;
    public short field4;
    public byte field5;
    public byte field6;
    public byte field7;
    public byte field8_dim1;
    public byte field8_dim2;
    public byte field8[][];
    public int field9;
    public long field10;
    public byte field11;
    public byte field12[][][][];
    public byte field13;
    public byte field14;
    public byte field15;
    public byte field16;
    public byte field17;
    public byte field18;
    public byte field19;
    public byte field20;
    public byte field21;
    public byte field22;
    public byte field23;
    public byte field24;
    public byte filler1;
    public byte field25;
    public byte field26;
    public byte field27;
    public byte field28;
    public short field29;
    public short field30;
    public int field31;
    public int field32;
    public long field33;
    public long field34;
 
    public bitfield_t()
    {
        field2 = new byte[2][4];
        field12 = new byte[3][2][2][2];
    }
 
    public static final long ZCM_FINGERPRINT;
    public static final long ZCM_FINGERPRINT_BASE = 0x4e73ecb0ea215bc2L;
 
    public static final boolean IS_LITTLE_ENDIAN = false;
    public static final byte FIELD22_TEST = (byte) 0xff;
    public static final byte FIELD23_TEST = (byte) 3;
    public static final byte FIELD24_TEST = (byte) 0x07;
    public static final byte SIGN_TEST_0 = (byte) 0x0f;
    public static final byte SIGN_TEST_1 = (byte) 0xf0;
    public static final byte SIGN_TEST_2 = (byte) 0x7f;
    public static final byte SIGN_TEST_3 = (byte) 0x80;
    public static final short SIGN_TEST_4 = (short) 0x1fff;
    public static final short SIGN_TEST_5 = (short) 0xe000;
    public static final short SIGN_TEST_6 = (short) 0x7fff;
    public static final short SIGN_TEST_7 = (short) 0x8000;
    public static final int SIGN_TEST_8 = 0x01ffffff;
    public static final int SIGN_TEST_9 = 0xfe000000;
    public static final int SIGN_TEST_10 = 0x7fffffff;
    public static final int SIGN_TEST_11 = 0x80000000;
    public static final long SIGN_TEST_12 = 0xffffffffffffffffL;
    public static final long SIGN_TEST_13 = 0x00ffffffffffffffL;
    public static final long SIGN_TEST_14 = 0xff00000000000000L;
    public static final long SIGN_TEST_15 = 0x7fffffffffffffffL;
    public static final long SIGN_TEST_16 = 0x8000000000000000L;
    public static final byte SIGN_TEST_17 = (byte) 0x07;
    public static final byte SIGN_TEST_18 = (byte) 0x7f;
    public static final byte SIGN_TEST_19 = (byte) 0x07;
    public static final byte SIGN_TEST_20 = (byte) 0x7f;
    public static final short SIGN_TEST_21 = (short) 0x0007;
    public static final short SIGN_TEST_22 = (short) 0x7fff;
    public static final int SIGN_TEST_23 = 0x00000007;
    public static final int SIGN_TEST_24 = 0x7fffffff;
    public static final long SIGN_TEST_25 = 0x0000000000000001L;
    public static final long SIGN_TEST_26 = 0x0000000000000007L;
    public static final long SIGN_TEST_27 = 0x7fffffffffffffffL;
    public static final byte SIGN_TEST_28 = (byte) 0x7f;
    public static final byte SIGN_TEST_29 = (byte) 0xff;
    public static final byte SIGN_TEST_30 = (byte) 0x7f;
    public static final byte SIGN_TEST_31 = (byte) 0xff;
    public static final byte SIGN_TEST_32 = (byte) 127;
    public static final byte SIGN_TEST_33 = (byte) -1;
    public static final short SIGN_TEST_34 = (short) 0x7fff;
    public static final short SIGN_TEST_35 = (short) 0xffff;
    public static final short SIGN_TEST_36 = (short) 32767;
    public static final short SIGN_TEST_37 = (short) -1;
    public static final int SIGN_TEST_38 = 0x7fffffff;
    public static final int SIGN_TEST_39 = 0xffffffff;
    public static final int SIGN_TEST_40 = 2147483647;
    public static final int SIGN_TEST_41 = -1;
    public static final long SIGN_TEST_42 = 0x7fffffffffffffffL;
    public static final long SIGN_TEST_43 = 0xffffffffffffffffL;
    public static final long SIGN_TEST_44 = 9223372036854775807L;
    public static final long SIGN_TEST_45 = -1L;

    static {
        ZCM_FINGERPRINT = _hashRecursive(new ArrayList<Class<?>>());
    }
 
    public static long _hashRecursive(ArrayList<Class<?>> classes)
    {
        if (classes.contains(javazcm.types.bitfield_t.class))
            return 0L;
 
        classes.add(javazcm.types.bitfield_t.class);
        long hash = ZCM_FINGERPRINT_BASE
            ;
        classes.remove(classes.size() - 1);
        return (hash<<1) + ((hash>>>63)&1);
    }
 
    public void encode(ZCMDataOutputStream outs) throws IOException
    {
        outs.writeLong(ZCM_FINGERPRINT);
        _encodeRecursive(outs);
    }
 
    public void _encodeRecursive(ZCMDataOutputStream outs) throws IOException
    {
        // Start of bitfield 0

        outs.writeBits(this.field1, 2);
 
        for (int a = 0; a < 2; ++a) {
            for (int b = 0; b < 4; ++b) {
                outs.writeBits(this.field2[a][b], 1);
            }
        }
 
        outs.writeBits(this.field3, 4);
 
        outs.writeBits(this.field4, 3);
 
        outs.resetBits();

        // End of bitfield 0

        outs.writeByte(this.field5);
 
        // Start of bitfield 1

        outs.writeBits(this.field6, 2);
 
        outs.writeBits(this.field7, 3);
 
        outs.writeBits(this.field8_dim1, 4);
 
        outs.resetBits();

        // End of bitfield 1

        outs.writeByte(this.field8_dim2);
 
        // Start of bitfield 2

        for (int a = 0; a < this.field8_dim1; ++a) {
            for (int b = 0; b < this.field8_dim2; ++b) {
                outs.writeBits(this.field8[a][b], 3);
            }
        }
 
        outs.writeBits(this.field9, 28);
 
        outs.writeBits(this.field10, 55);
 
        outs.writeBits(this.field11, 2);
 
        for (int a = 0; a < 3; ++a) {
            for (int b = 0; b < 2; ++b) {
                for (int c = 0; c < 2; ++c) {
                    for (int d = 0; d < 2; ++d) {
                        outs.writeBits(this.field12[a][b][c][d], 3);
                    }
                }
            }
        }
 
        outs.resetBits();

        // End of bitfield 2

        outs.writeByte(this.field13);
 
        // Start of bitfield 3

        outs.writeBits(this.field14, 4);
 
        outs.writeBits(this.field15, 7);
 
        outs.writeBits(this.field16, 7);
 
        outs.resetBits();

        // End of bitfield 3

        outs.writeByte(this.field17);
 
        // Start of bitfield 4

        outs.writeBits(this.field18, 4);
 
        outs.writeBits(this.field19, 7);
 
        outs.writeBits(this.field20, 7);
 
        outs.resetBits();

        // End of bitfield 4

        outs.writeByte(this.field21);
 
        // Start of bitfield 5

        outs.writeBits(this.field22, 8);
 
        outs.writeBits(this.field23, 3);
 
        outs.writeBits(this.field24, 3);
 
        outs.resetBits();

        // End of bitfield 5

        outs.writeByte(this.filler1);
 
        // Start of bitfield 6

        outs.writeBits(this.field25, 2);
 
        outs.writeBits(this.field26, 8);
 
        outs.writeBits(this.field27, 2);
 
        outs.writeBits(this.field28, 7);
 
        outs.writeBits(this.field29, 2);
 
        outs.writeBits(this.field30, 15);
 
        outs.writeBits(this.field31, 4);
 
        outs.writeBits(this.field32, 31);
 
        outs.writeBits(this.field33, 4);
 
        outs.writeBits(this.field34, 63);
 
        outs.resetBits();

        // End of bitfield 6
    }
 
    public bitfield_t(byte[] data) throws IOException
    {
        this(new ZCMDataInputStream(data));
    }
 
    public bitfield_t(ZCMDataInputStream ins) throws IOException
    {
        if (ins.readLong() != ZCM_FINGERPRINT)
            throw new IOException("ZCM Decode error: bad fingerprint");
 
        _decodeRecursive(ins);
    }
 
    public static javazcm.types.bitfield_t _decodeRecursiveFactory(ZCMDataInputStream ins) throws IOException
    {
        javazcm.types.bitfield_t o = new javazcm.types.bitfield_t();
        o._decodeRecursive(ins);
        return o;
    }
 
    public void _decodeRecursive(ZCMDataInputStream ins) throws IOException
    {
        // Start of bitfield 0

        this.field1 = ins.readByteBits(2, true);
 
        this.field2 = new byte[(int) 2][(int) 4];
        for (int a = 0; a < 2; ++a) {
            for (int b = 0; b < 4; ++b) {
                this.field2[a][b] = ins.readByteBits(1, true);
            }
        }
 
        this.field3 = ins.readShortBits(4, true);
 
        this.field4 = ins.readShortBits(3, true);
 
        ins.resetBits();

        // End of bitfield 0

        this.field5 = ins.readByte();
 
        // Start of bitfield 1

        this.field6 = ins.readByteBits(2, true);
 
        this.field7 = ins.readByteBits(3, true);
 
        this.field8_dim1 = ins.readByteBits(4, true);
 
        ins.resetBits();

        // End of bitfield 1

        this.field8_dim2 = ins.readByte();
 
        // Start of bitfield 2

        this.field8 = new byte[(int) field8_dim1][(int) field8_dim2];
        for (int a = 0; a < this.field8_dim1; ++a) {
            for (int b = 0; b < this.field8_dim2; ++b) {
                this.field8[a][b] = ins.readByteBits(3, true);
            }
        }
 
        this.field9 = ins.readIntBits(28, true);
 
        this.field10 = ins.readLongBits(55, true);
 
        this.field11 = ins.readByteBits(2, false);
 
        this.field12 = new byte[(int) 3][(int) 2][(int) 2][(int) 2];
        for (int a = 0; a < 3; ++a) {
            for (int b = 0; b < 2; ++b) {
                for (int c = 0; c < 2; ++c) {
                    for (int d = 0; d < 2; ++d) {
                        this.field12[a][b][c][d] = ins.readByteBits(3, false);
                    }
                }
            }
        }
 
        ins.resetBits();

        // End of bitfield 2

        this.field13 = ins.readByte();
 
        // Start of bitfield 3

        this.field14 = ins.readByteBits(4, true);
 
        this.field15 = ins.readByteBits(7, true);
 
        this.field16 = ins.readByteBits(7, true);
 
        ins.resetBits();

        // End of bitfield 3

        this.field17 = ins.readByte();
 
        // Start of bitfield 4

        this.field18 = ins.readByteBits(4, false);
 
        this.field19 = ins.readByteBits(7, false);
 
        this.field20 = ins.readByteBits(7, false);
 
        ins.resetBits();

        // End of bitfield 4

        this.field21 = ins.readByte();
 
        // Start of bitfield 5

        this.field22 = ins.readByteBits(8, false);
 
        this.field23 = ins.readByteBits(3, false);
 
        this.field24 = ins.readByteBits(3, false);
 
        ins.resetBits();

        // End of bitfield 5

        this.filler1 = ins.readByte();
 
        // Start of bitfield 6

        this.field25 = ins.readByteBits(2, false);
 
        this.field26 = ins.readByteBits(8, false);
 
        this.field27 = ins.readByteBits(2, false);
 
        this.field28 = ins.readByteBits(7, false);
 
        this.field29 = ins.readShortBits(2, false);
 
        this.field30 = ins.readShortBits(15, false);
 
        this.field31 = ins.readIntBits(4, false);
 
        this.field32 = ins.readIntBits(31, false);
 
        this.field33 = ins.readLongBits(4, false);
 
        this.field34 = ins.readLongBits(63, false);
 
        ins.resetBits();

        // End of bitfield 6
    }
 
    public javazcm.types.bitfield_t copy()
    {
        javazcm.types.bitfield_t outobj = new javazcm.types.bitfield_t();
        outobj.field1 = this.field1;
 
        outobj.field2 = new byte[(int) 2][(int) 4];
        for (int a = 0; a < 2; ++a) {
            System.arraycopy(this.field2[a], 0, outobj.field2[a], 0, 4);        }
 
        outobj.field3 = this.field3;
 
        outobj.field4 = this.field4;
 
        outobj.field5 = this.field5;
 
        outobj.field6 = this.field6;
 
        outobj.field7 = this.field7;
 
        outobj.field8_dim1 = this.field8_dim1;
 
        outobj.field8_dim2 = this.field8_dim2;
 
        outobj.field8 = new byte[(int) field8_dim1][(int) field8_dim2];
        for (int a = 0; a < this.field8_dim1; ++a) {
            if (this.field8_dim2 > 0)
                System.arraycopy(this.field8[a], 0, outobj.field8[a], 0, this.field8_dim2);        }
 
        outobj.field9 = this.field9;
 
        outobj.field10 = this.field10;
 
        outobj.field11 = this.field11;
 
        outobj.field12 = new byte[(int) 3][(int) 2][(int) 2][(int) 2];
        for (int a = 0; a < 3; ++a) {
            for (int b = 0; b < 2; ++b) {
                for (int c = 0; c < 2; ++c) {
                    System.arraycopy(this.field12[a][b][c], 0, outobj.field12[a][b][c], 0, 2);                }
            }
        }
 
        outobj.field13 = this.field13;
 
        outobj.field14 = this.field14;
 
        outobj.field15 = this.field15;
 
        outobj.field16 = this.field16;
 
        outobj.field17 = this.field17;
 
        outobj.field18 = this.field18;
 
        outobj.field19 = this.field19;
 
        outobj.field20 = this.field20;
 
        outobj.field21 = this.field21;
 
        outobj.field22 = this.field22;
 
        outobj.field23 = this.field23;
 
        outobj.field24 = this.field24;
 
        outobj.filler1 = this.filler1;
 
        outobj.field25 = this.field25;
 
        outobj.field26 = this.field26;
 
        outobj.field27 = this.field27;
 
        outobj.field28 = this.field28;
 
        outobj.field29 = this.field29;
 
        outobj.field30 = this.field30;
 
        outobj.field31 = this.field31;
 
        outobj.field32 = this.field32;
 
        outobj.field33 = this.field33;
 
        outobj.field34 = this.field34;
 
        return outobj;
    }
 
}

